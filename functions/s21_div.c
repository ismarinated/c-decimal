#include "../s21_decimal.h"

// Функция s21_div выполняет деление двух чисел типа s21_decimal.
// Параметры:
// - value_1: Делимое.
// - value_2: Делитель.
// - result: Указатель на переменную, в которую будет сохранён результат
// деления. Возвращаемое значение: код результата операции.

int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
  int res = 0;  // Переменная для хранения кода результата операции.

  // Проверка на деление на ноль. Если делитель равен нулю, устанавливается код
  // ошибки 3.
  if (is_zero(value_2)) {
    res = 3;
  } else {
    // Инициализируем переменную result нулями, чтобы избежать случайных
    // значений.
    *result = (s21_decimal){{0, 0, 0, 0}};

    // Если делимое не равно нулю, продолжаем выполнение операции деления.
    if (!is_zero(value_1)) {
      // Пока делимое меньше делителя, увеличиваем его экспоненту (передвигаем
      // десятичную точку вправо), чтобы обеспечить корректное деление.
      while (s21_is_less(
          (s21_decimal){{value_1.bits[0], value_1.bits[1], value_1.bits[2], 0}},
          (s21_decimal){
              {value_2.bits[0], value_2.bits[1], value_2.bits[2], 0}})) {
        increase_exponent(&value_1);
      }

      // Вычисляем текущий знак результата, который зависит от знаков делимого и
      // делителя.
      int cur_sgn = getBit(get_sign(value_1) + get_sign(value_2), 0);

      // Выполняем основную операцию деления, сохраняя результат и оставшуюся
      // экспоненту.
      int cur_exp = remainder_div(value_1, value_2, result);

      // Устанавливаем знак и экспоненту в результирующем числе.

      set_sign(result, cur_sgn);
      set_scale(result, cur_exp);

      // Если оставшаяся экспонента отрицательная, это может свидетельствовать о
      // переполнении или потере точности. Устанавливаем соответствующий код
      // ошибки (1 или 2).
      if (cur_exp < 0) {
        res = 1 + cur_sgn;
      }
    }
  }

  return res;
}