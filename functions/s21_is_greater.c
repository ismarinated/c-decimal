#include "../s21_decimal.h"

// Функция s21_is_greater проверяет, больше ли число value_1 по сравнению с
// value_2. Параметры:
// - value_1: первое число для сравнения.
// - value_2: второе число для сравнения.
// Возвращаемое значение: 1, если value_1 больше, и 0 в противном случае.

int s21_is_greater(s21_decimal value_1, s21_decimal value_2) {
  s21_big_decimal value_1_big, value_2_big;

  // Преобразуем оба числа из s21_decimal в s21_big_decimal для более точного
  // сравнения.
  decimal_to_big_decimal(value_1, &value_1_big);
  decimal_to_big_decimal(value_2, &value_2_big);

  // Нормализуем оба числа, чтобы привести их к одному и тому же масштабу
  // (экспоненте).
  normalize_big(&value_1_big, &value_2_big);

  int res = 0;

  // Проверяем, являются ли оба числа нулями. Если да, возвращаем 0 (они равны,
  // поэтому не больше).
  if (is_zero(value_1) && is_zero(value_2)) {
    res = 0;
  }
  // Если знак первого числа меньше знака второго, значит первое число
  // положительное, а второе отрицательное. В этом случае возвращаем 1, т.к.
  // положительное число всегда больше отрицательного.
  else if (get_sign(value_1) < get_sign(value_2)) {
    res = 1;
  }
  // Если знак первого числа больше знака второго, значит первое число
  // отрицательное, а второе положительное. В этом случае возвращаем 0, т.к.
  // отрицательное число всегда меньше положительного.
  else if (get_sign(value_1) > get_sign(value_2)) {
    res = 0;
  }
  // Если оба числа равны, возвращаем 0, т.к. ни одно не больше другого.
  else if (s21_is_equal(value_1, value_2)) {
    res = 0;
  }
  // Если знаки одинаковы и числа не равны, сравниваем их побитово.
  else {
    for (int i = 191; i >= 0; i--) {
      if (getBit(value_1_big.bits[i / 32], i % 32) >
          getBit(value_2_big.bits[i / 32], i % 32)) {
        res = 1;
        break;
      } else if (getBit(value_1_big.bits[i / 32], i % 32) <
                 getBit(value_2_big.bits[i / 32], i % 32)) {
        res = 0;
        break;
      }
    }
    // Если оба числа отрицательные, меняем результат на противоположный,
    // т.к. у отрицательных чисел большее по модулю значение является меньшим.
    if (get_sign(value_1) && get_sign(value_2)) {
      res = res ? 0 : 1;
    }
  }
  return res;
}