#include "../s21_decimal.h"

// Функция s21_mul выполняет умножение двух чисел типа s21_decimal и записывает
// результат в переменную result. Параметры:
// - value_1: первое число для умножения.
// - value_2: второе число для умножения.
// - result: указатель на переменную, в которую будет сохранён результат
// умножения. Возвращаемое значение: 0 - успех, 1 или 2 - ошибка (переполнение
// или другие проблемы).

int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
  int res = 0;  // Инициализация переменной для хранения кода результата.

  // Проверяем, не произойдёт ли переполнение при умножении.
  int bits = overflow_check(value_1, value_2);

  // Получаем экспоненты обоих чисел.
  int a = get_exp(value_1);
  int b = get_exp(value_2);
  // Вычисляем новую экспоненту для результата.
  int cur_exp = (a + b);

  // Вычисляем знак результата на основе знаков входных чисел.
  int cur_sgn = (getBit(get_sign(value_1) + get_sign(value_2), 0));

  // Если число битов после умножения меньше 96, используем простое умножение.
  if (bits < 96) {
    basic_mul(value_1, value_2, result);
  } else {
    // В противном случае используем long_mul для работы с большими числами,
    // и корректируем экспоненту на основе результата.
    cur_exp -= long_mul(value_1, value_2, result);
  }

  // Устанавливаем экспоненту и знак в старшем бите результата.
  (*result).bits[3] = (cur_exp << 16 | (unsigned)cur_sgn << 31);

  // Если текущая экспонента больше 28 (максимально допустимое значение),
  // уменьшаем экспоненту, чтобы сохранить число в допустимом диапазоне.
  while (get_exp(*result) > 28) {
    decrease_exponent(result);
    // Если после уменьшения экспоненты результат стал равен нулю и экспонента
    // не равна 28, устанавливаем код ошибки (переполнение).
    if (is_zero(*result) && get_exp(*result) != 28) {
      res = 1 + cur_sgn;
    }
  }

  return res;
}