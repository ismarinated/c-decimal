#include "../s21_decimal.h"

// Функция s21_add выполняет сложение двух значений типа s21_decimal.
// Параметры:
// - value_1: Первое значение для сложения.
// - value_2: Второе значение для сложения.
// - result: Указатель на переменную, в которую будет сохранён результат
// сложения. Возвращаемое значение: код результата операции.

int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result) {
  // Инициализируем переменную для хранения кода результата операции.
  int res = 0;

  // Обнуляем все биты в структуре s21_decimal, на которую указывает result.
  // Это делается для того, чтобы избежать случайных значений в результатах.
  *result = (s21_decimal){{0, 0, 0, 0}};

  // Функция equal_exponents приводит экспоненты двух значений к одному и тому
  // же значению. Это необходимо, чтобы сложение выполнялось корректно (с учётом
  // дробной части).
  equal_exponents(&value_1, &value_2);

  // Если знаки у обоих чисел одинаковы (оба положительные или оба
  // отрицательные), мы можем выполнить обычное сложение.
  if (get_sign(value_1) == get_sign(value_2)) {
    // Функция basic_add выполняет простое сложение двух чисел без учёта знака.
    // Результат сохраняется в переменной, на которую указывает result.
    basic_add(value_1, value_2, result, &res);
  } else if (get_sign(value_1) > get_sign(value_2)) {
    // Если первое число отрицательное, а второе положительное (или наоборот),
    // сначала инвертируем знак первого числа.

    value_1.bits[3] = toggleBit(value_1.bits[3], 31);

    // Сравниваем числа. Если второе число больше или равно первому,
    // то вычитаем первое число из второго.
    if (s21_is_greater_or_equal(value_2, value_1)) {
      basic_sub(value_2, value_1, result, &res);
    } else {
      // Если первое число больше второго, вычитаем второе из первого,
      // и затем инвертируем знак результата.
      basic_sub(value_1, value_2, result, &res);
      (*result).bits[3] = toggleBit((*result).bits[3], 31);
    }
  } else {
    // Этот блок аналогичен предыдущему, но здесь мы работаем с ситуацией,
    // когда второе число отрицательное, а первое положительное.
    value_2.bits[3] = toggleBit(value_2.bits[3], 31);

    // Сравниваем числа. Если первое число больше или равно второму,
    // то вычитаем второе число из первого.
    if (s21_is_greater_or_equal(value_1, value_2)) {
      basic_sub(value_1, value_2, result, &res);
    } else {
      // Если второе число больше первого, вычитаем первое из второго,
      // и затем инвертируем знак результата.
      basic_sub(value_2, value_1, result, &res);
      (*result).bits[3] = toggleBit((*result).bits[3], 31);
    }
  }

  return res;
}